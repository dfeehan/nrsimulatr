---
title: "Stochastic block model network reporting simulation"
author: "Dennis Feehan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sbm-simulation}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r}
library(knitr)
opts_chunk$set(eval=FALSE)
```

```{r}
library(igraph)
library(dplyr)
library(tidyr)
library(stringr)
```

```{r}
set.seed(12345)
```

Now set up the params for one random draw.

```{r}
sim.params <- expand.grid(# size of total population, U
                          N=10e3,
                          #N=10e3,
                          # frame population is half of total
                          p.F=.5,
                          # hidden popn is 3 percent of total
                          p.H=.03,
                          # prob of edge between two nodes in the same group
                          pi.within=.05,
                          # relative prob of edge between two nodes not in the same group
                          rho=.1,
                          tau=.5)

```

Now draw the actual random graph.

```{r}
params <- sbm_params(sim.params, type="4group_1param_nested")
this.g <- generate_graph(params)
this.g.df <- get.data.frame(this.g, 'vertices')
```

Next, generate the reporting graph.

(NB: right now, converting to a reporting graph is quite slow.)

```{r}
rep.params <- perfect_reporting()
this.r <- reporting_graph(rep.params, this.g)
```

Then take a sample (but we'll just keep everything with a census).


```{r}

this.r.sample <- sample_graph(entire_census(), this.r)
#this.r.sample <- sample_graph(frame_srs(params=list(sampling.frac=.1)), this.r)

```

Finally, produce estimates

```{r}

these.ests <- sbm_estimates(this.r.sample)

```

Also, get the expected values for this parameter combination

TODO - should probably just use sbm_ev function now...

```{r}
params <- sbm_params(sim.params, type="4group_1param_nested")

this.inF <- c(1,1,0,0)
this.inH <- c(0,1,0,1)
this.inU <- c(1,1,1,1)

these.block.sizes <- params$block.sizes
this.pref.matrix <- params$pref.matrix
```

```{r}

eec.dbar.F.F <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, this.inF, this.inF)
    return(2*eec / sum(bs*this.inF))
}

eec.dbar.F.U <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, this.inF, c(1,1,1,1))
    return(2*eec / sum(bs*this.inF))
}

eec.dbar.U.F <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, c(1,1,1,1), this.inF)
    return(2*eec / sum(bs))
}

eec.dbar.H.F <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, this.inH, this.inF)
    return(2*eec / sum(bs*this.inH))
}

```

```{r}
this.N <- sum(these.block.sizes)
this.N.F <- sum(these.block.sizes * this.inF)

eec.dbar.F.F(this.pref.matrix, these.block.sizes)

eec.dbar.F.U(this.pref.matrix, these.block.sizes)

eec.dbar.U.F(this.pref.matrix, these.block.sizes)

## good, this works...
(this.N/this.N.F)*eec.dbar.U.F(this.pref.matrix, these.block.sizes)


```

```{r}

this.dbar.F.F <- eec.dbar.F.F(this.pref.matrix, these.block.sizes)
this.dbar.U.F <- eec.dbar.U.F(this.pref.matrix, these.block.sizes)
this.dbar.H.F <- eec.dbar.H.F(this.pref.matrix, these.block.sizes)

this.phi.F <- this.dbar.F.F / this.dbar.U.F
this.delta.F <- this.dbar.H.F / this.dbar.F.F

```
