---
title: "Stochastic block model network reporting simulation"
author: "Dennis Feehan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sbm-simulation}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r}
library(knitr)
opts_chunk$set(eval=FALSE)
```

```{r}
library(igraph)
library(dplyr)
library(tidyr)
library(stringr)
```

```{r}
set.seed(12345)
```

Now set up the params for one random draw.

```{r}
sim.params <- expand.grid(# size of total population, U
                          N=10e3,
                          #N=10e3,
                          # frame population is half of total
                          p.F=.5,
                          # hidden popn is 3 percent of total
                          p.H=.03,
                          # prob of edge between two nodes in the same group
                          pi.within=.05,
                          # relative prob of edge between two nodes not in the same group
                          rho=.1,
                          tau=.5)


```

Now draw the actual random graph.

```{r}
this.g <- draw.4group.graph(sim.params, type="nested")
this.g.df <- get.data.frame(this.g, 'vertices')
```

Next, generate the reporting graph.

```{r}
this.r <- reporting.graph(this.g, 
                          hidden.popn=c('FH', 'notFH'),
                          frame.popn=c('FH', 'FnotH'))
```

Finally, produce estimates

```{r}

these.ests <- reporting.estimates(this.r, 
                                  hidden.popn=c('FH', 'notFH'),
                                  frame.popn=c('FH', 'FnotH'))

```

Also, get the expected values for this parameter combination

```{r}
these.params <- sim.params[1,]
this.inF <- c(1,1,0,0)
this.inH <- c(0,1,0,1)
this.inU <- c(1,1,1,1)
these.block.sizes <- graph.attributes(this.r)$block.sizes

this.pref.matrix <- pref.matrix.4group(these.block.sizes,
                                       these.params$pi.within,
                                       these.params$rho,
                                       type="nested",
                                       inF=this.inF,
                                       inH=this.inH)


```

```{r}

eec.dbar.F.F <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, this.inF, this.inF)
    return(2*eec / sum(bs*this.inF))
}

eec.dbar.F.U <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, this.inF, c(1,1,1,1))
    return(2*eec / sum(bs*this.inF))
}

eec.dbar.U.F <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, c(1,1,1,1), this.inF)
    return(2*eec / sum(bs))
}

eec.dbar.H.F <- function(pm, bs) {
    eec <- expected.edgecount.4group(pm, bs, this.inH, this.inF)
    return(2*eec / sum(bs*this.inH))
}

#eec.TODO <- expected.edgecount.4group(this.pref.matrix,
#                                      these.block.sizes,
#                                      first.group=TODO,
#                                      second.group=TODO)

```

```{r}
this.N <- sum(these.block.sizes)
this.N.F <- sum(these.block.sizes * this.inF)

eec.dbar.F.F(this.pref.matrix, these.block.sizes)

eec.dbar.F.U(this.pref.matrix, these.block.sizes)

eec.dbar.U.F(this.pref.matrix, these.block.sizes)

## good, this works...
(this.N/this.N.F)*eec.dbar.U.F(this.pref.matrix, these.block.sizes)


```

```{r}

this.dbar.F.F <- eec.dbar.F.F(this.pref.matrix, these.block.sizes)
this.dbar.U.F <- eec.dbar.U.F(this.pref.matrix, these.block.sizes)
this.dbar.H.F <- eec.dbar.H.F(this.pref.matrix, these.block.sizes)

this.phi.F <- this.dbar.F.F / this.dbar.U.F
this.delta.F <- this.dbar.H.F / this.dbar.F.F

```
